use crate::general_pattern::pattern::{get_cartesian_transform_from_builder, get_composition_pattern_cv, get_linear_transform, BuildCartesianTransformCV, BuildCompositionCV, BuildLinearTransformCV};
use std::collections::BTreeSet;
use std::convert::TryInto;
use std::rc::Rc;
use quantifiable_derive::Quantifiable;

use rand::prelude::StdRng;
use crate::{match_object_panic, Message, Time};

use crate::AsMessage;
use crate::config_parser::ConfigurationValue;
use crate::general_pattern::{new_pattern, GeneralPatternBuilderArgument};
use crate::general_pattern::one_to_many_pattern::neighbours::{immediate_neighbours_cv_builder, ImmediateNeighboursCVBuilder};
use crate::general_pattern::pattern::extra::{get_candidates_selection, get_cartesian_transform, get_hotspot_destination};
use crate::packet::ReferredPayload;
use crate::topology::cartesian::CartesianData;
use crate::topology::Topology;
use crate::traffic::{build_traffic_map_cv, build_traffic_sum_cv, new_traffic, BuildTrafficMapCVArgs, BuildTrafficSumCVArgs, TaskTrafficState, Traffic, TrafficBuilderArgument, TrafficError};
use crate::traffic::basic::{build_send_message_to_vector_cv, SendMessageToVectorCVBuilder};

/**
Traffic which allow tasks to generate messages when they have enough credits.
After generating the messages, the credits are consumed.
A task gain credits when it consumes messages, and an initial amount of credits per task can be set.
```ignore
TrafficManager{
	SimplePattern: RandomPermutation, //specify the SimplePattern of the communication
	tasks: 1000, //specify the number of tasks
	credits_to_activate: 10, //specify the number of credits needed to generate messages
	messages_per_transition: 1, //specify the number of messages each task can sent when consuming credits
	credits_per_received_message: 1, //specify the number of credits to gain when a message is received
	initial_credits: Hotspots{destinations: [1]}, //specify the initial amount of credits per task
}
```
 **/
#[derive(Quantifiable)]
#[derive(Debug)]
pub struct TrafficManager
{
	///Number of tasks applying this traffic.
	tasks: usize,
	///The SimplePattern of the communication.
	traffic: Box<dyn Traffic>,
	///Credits needed to activate the transition
	credits_to_activate:usize,
	///Credit count per origin
	credits: Vec<usize>,
	///The credits to sum when a message is received
	credits_per_received_message:usize,
	///Messages per transition
	messages_per_transition:usize,
	///The number of messages each task has pending to sent.
	available_messages_to_send: Vec<usize>,
	///Set of generated messages. (For debug purposes.)
	generated_messages: BTreeSet<u128>,
	next_id: u128,
}

impl Traffic for TrafficManager
{
	fn generate_message(&mut self, origin:usize, cycle:Time, topology: Option<&dyn Topology>, rng: &mut StdRng) -> Result<Rc<Message>,TrafficError>
	{
		if origin>=self.tasks
		{
			panic!("origin {} does not belong to the traffic",origin);
		}
		if self.available_messages_to_send[origin] == 0
		{
			panic!("origin {} has no pending messages",origin);
		}
		self.available_messages_to_send[origin]-=1;
		let message = self.traffic.generate_message(origin, cycle, topology, rng)?;
		let id = u128::from_le_bytes(message.payload()[0..16].try_into().expect("bad payload"));
		self.generated_messages.insert(id);
		let mut payload = Vec::with_capacity(message.payload().len() + 4);
		payload.extend_from_slice(&id.to_le_bytes());
		payload.extend_from_slice(message.payload());
		let message = Rc::new(Message {
			origin,
			destination: message.destination,
			size: message.size,
			creation_cycle: message.creation_cycle,
			payload,
			id_traffic: message.id_traffic,
		});

		self.next_id += 1;
		Ok(message)
	}
	fn probability_per_cycle(&self, task:usize) -> f32
	{
		if self.available_messages_to_send[task]>0 && self.traffic.probability_per_cycle(task) > 0.0
		{
			1.0
		}
		else
		{
			0.0
		}
	}

	fn should_generate( &mut self, task:usize, cycle:Time, rng: &mut StdRng) -> bool
	{
		if self.credits[task] >= self.credits_to_activate
		{
			self.available_messages_to_send[task] += self.messages_per_transition;
			self.credits[task] -= self.credits_to_activate;
		}
		self.available_messages_to_send[task] > 0 && self.traffic.should_generate(task, cycle, rng)
	}

	fn consume(&mut self, task:usize, message: &dyn AsMessage, cycle:Time, topology: Option<&dyn Topology>, rng: &mut StdRng) -> bool
	{
		self.credits[task] += self.credits_per_received_message;
		let id = u128::from_le_bytes(message.payload()[0..16].try_into().expect("bad payload"));
		let sub_message_payload = &message.payload()[16..];
		let mut inner_message = ReferredPayload::from(message);
		inner_message.payload = sub_message_payload;
		if  inner_message.destination != task
		{
			panic!("Message {} was not sent to task {}",id,task);
		}
		if self.generated_messages.remove(&id)
		{
			self.traffic.consume(task, &inner_message, cycle, topology, rng)
		}
		else
		{
			panic!("Message {} was not generated by TrafficManager",id);
		}
	}
	fn is_finished(&mut self, rng: Option<&mut StdRng>) -> bool
	{
		if self.traffic.is_finished(rng) {
			return true;
		}

		if !self.generated_messages.is_empty() //messages traveling through the network
		{
			return false;
		}

		if self.available_messages_to_send.iter().sum::<usize>() > 0 //messages waiting to be sent
		{
			return false;
		}

		//if there is a task with enough credits to activate, then it is not finished
		for &c in self.credits.iter()
		{
			if c >= self.credits_to_activate
			{
				return false;
			}
		}
		panic!("TrafficManager is not able to finish the underlying traffic");
	}
	fn task_state(&mut self, task:usize, cycle:Time) -> Option<TaskTrafficState>
	{
		self.traffic.task_state(task, cycle)
	}

	fn number_tasks(&self) -> usize {
		self.tasks
	}
}

impl TrafficManager
{
	pub fn new(arg:TrafficBuilderArgument) -> TrafficManager
	{
		let mut tasks=None;
		let mut subtraffic =None;
		let mut credits_to_activate=None;
		let mut credits_per_received_message=None;
		let mut messages_per_transition=None;
		let mut initial_credits=None;

		match_object_panic!(arg.cv,"TrafficManager",value,
			"traffic" => subtraffic=Some(new_traffic(TrafficBuilderArgument{cv:value, plugs:arg.plugs, topology:arg.topology, rng:arg.rng})),
			"tasks" | "servers" => tasks=Some(value.as_usize().expect("bad value for tasks")),
			"credits_to_activate" => credits_to_activate=Some(value.as_usize().expect("bad value for credits_to_activate")),
			"credits_per_received_message" => credits_per_received_message=Some(value.as_usize().expect("bad value for credits_per_received_message")),
			"messages_per_transition" => messages_per_transition=Some(value.as_usize().expect("bad value for messages_per_transition")),
			"initial_credits" => initial_credits=Some(new_pattern(GeneralPatternBuilderArgument{cv:value,plugs:arg.plugs})),
		);

		let tasks=tasks.expect("There were no tasks");
		let subtraffic = subtraffic.expect("There were no subtraffic");
		let credits_to_activate=credits_to_activate.expect("There were no credits_to_activate");
		let credits_per_received_message=credits_per_received_message.expect("There were no credits_per_received_message");
		let messages_per_transition=messages_per_transition.expect("There were no messages_per_transition");
		let mut initial_credits=initial_credits.expect("There were no initial_credits");

		let available_messages_to_send = vec![0;tasks];
		initial_credits.initialize(tasks, tasks, arg.topology, arg.rng);
		let credits = (0..tasks).map(|i| initial_credits.get_destination(i, arg.topology, arg.rng)).collect::<Vec<usize>>();

		TrafficManager {
			tasks,
			traffic: subtraffic,
			credits_to_activate,
			credits,
			credits_per_received_message,
			messages_per_transition,
			available_messages_to_send,
			generated_messages: BTreeSet::new(),
			next_id: 0,
		}
	}
}

//TrafficManager CV builder
pub struct BuildTrafficManagerCVArgs{
	pub tasks: usize,
	pub credits_to_activate:usize,
	pub messages_per_transition: usize,
	pub credits_per_received_message: usize,
	pub traffic: ConfigurationValue,
	pub initial_credits: ConfigurationValue,
}

pub fn get_traffic_manager(args: BuildTrafficManagerCVArgs) -> ConfigurationValue
{
	let arg_vec = vec![
		("tasks".to_string(), ConfigurationValue::Number(args.tasks as f64)),
		("credits_to_activate".to_string(), ConfigurationValue::Number(args.credits_to_activate as f64)),
		("messages_per_transition".to_string(), ConfigurationValue::Number(args.messages_per_transition as f64)),
		("credits_per_received_message".to_string(), ConfigurationValue::Number(args.credits_per_received_message as f64)),
		("traffic".to_string(), args.traffic),
		("initial_credits".to_string(), args.initial_credits),
	];

	ConfigurationValue::Object("TrafficManager".to_string(), arg_vec)
}

#[derive(Debug, Quantifiable)]
pub struct MessageSizeModifier {
	/// The traffic to modify
	traffic: Box<dyn Traffic>,
	/// id of the message
	id_next: u128,
	/// Hashmap with the original size of the messages
	original_size: std::collections::HashMap<u128, usize>,
	/// Vector with the size of the messages
	message_sizes:Vec<usize>,
	/// Vector with the messages sent by each task
	messages_sent: Vec<usize>,
}

impl Traffic for MessageSizeModifier {
	fn generate_message(&mut self, origin:usize, cycle:Time, topology: Option<&dyn Topology>, rng: &mut StdRng) -> Result<Rc<Message>,TrafficError>
	{
		let message = self.traffic.generate_message(origin, cycle, topology, rng)?;
		let mut payload = Vec::with_capacity(message.payload().len() + 4);
		payload.extend_from_slice(&self.id_next.to_le_bytes());
		payload.extend_from_slice(message.payload());
		if self.messages_sent[origin] >= self.message_sizes.len()
		{
			panic!("MessageSizeModifier: origin {} has no more messages to send",origin);
		}
		let message = Rc::new(Message {
			origin,
			destination: message.destination,
			size: self.message_sizes[self.messages_sent[origin]],
			creation_cycle: message.creation_cycle,
			payload,
			id_traffic: message.id_traffic,
		});
		self.original_size.insert(self.id_next, message.size);
		self.messages_sent[origin] += 1;
		self.id_next += 1;
		Ok(message)
	}
	fn probability_per_cycle(&self, task:usize) -> f32
	{
		self.traffic.probability_per_cycle(task)
	}
	fn consume(&mut self, task:usize, message: &dyn AsMessage, cycle:Time, topology: Option<&dyn Topology>, rng: &mut StdRng) -> bool
	{
		let id = u128::from_le_bytes(message.payload()[0..16].try_into().expect("bad payload"));
		let sub_message_payload = &message.payload()[16..];
		let original_size = self.original_size.get(&id).expect("MessageSizeModifier: message not found");
		let mut inner_message = ReferredPayload::from(message);
		inner_message.payload = sub_message_payload;
		inner_message.size = *original_size;
		self.traffic.consume(task, &inner_message, cycle, topology, rng)
	}
	fn is_finished(&mut self, rng: Option<&mut StdRng>) -> bool
	{
		self.traffic.is_finished(rng)
	}
	fn should_generate( &mut self, task:usize, cycle:Time, rng: &mut StdRng) -> bool
	{
		self.traffic.should_generate(task, cycle, rng)
	}
	fn task_state(&mut self, task:usize, cycle:Time) -> Option<TaskTrafficState>
	{
		self.traffic.task_state(task, cycle)
	}
	fn number_tasks(&self) -> usize {
		self.traffic.number_tasks()
	}
}

impl MessageSizeModifier {
	pub fn new(arg:TrafficBuilderArgument) -> MessageSizeModifier
	{
		let mut traffic = None;
		let mut message_sizes = None;
		let mut tasks = None;

		match_object_panic!(arg.cv,"MessageSizeModifier",value,
			"tasks" | "servers" => tasks=Some(value.as_usize().expect("bad value for tasks")),
			"traffic" => traffic=Some(new_traffic(TrafficBuilderArgument{cv:value, plugs:arg.plugs, topology:arg.topology, rng:arg.rng})),
			"message_sizes" => message_sizes=Some(value.as_array().expect("bad value for size").iter().map(|v| v.as_usize().expect("bad value for size")).collect()),
		);

		let tasks = tasks.expect("There were no tasks");
		let traffic = traffic.expect("There were no traffic");
		let size = message_sizes.expect("There were no size");

		MessageSizeModifier {
			traffic,
			id_next: 0,
			original_size: std::collections::HashMap::new(),
			message_sizes: size,
			messages_sent: vec![0; tasks],
		}
	}
}

pub struct BuildMessageSizeModifierCVArgs{
	pub tasks: usize,
	pub traffic: ConfigurationValue,
	pub message_sizes: Vec<usize>,
}

pub fn get_message_size_modifier(args: BuildMessageSizeModifierCVArgs) -> ConfigurationValue
{
	let arg_vec = vec![
		("tasks".to_string(), ConfigurationValue::Number(args.tasks as f64)),
		("traffic".to_string(), args.traffic),
		("message_sizes".to_string(), ConfigurationValue::Array(args.message_sizes.iter().map(|&x| ConfigurationValue::Number(x as f64)).collect())),
	];

	ConfigurationValue::Object("MessageSizeModifier".to_string(), arg_vec)
}

/**
Mini-Kernels which imitate the behavior of real applications.

## Wavefront
The wavefront traffic is applied over a n-dimensional space.
Starts at the corner of the space (0,0,...,0) and ends at the opposite corner (n-1, n-1,..., n-1).

```ignore
	Wavefront{
		task_space: [10,10,10],
		data_size: 16,
	}
```
## LinearAll2All
The LinearAll2All traffic generates all2all in each row, column, etc., depending on the task space.
It is like an FFT.

```ignore
        LinearAll2All{
                task_space: [10,10],
                message_size: 16,
        }
```
This could simulate a FFT3D, where each task contains a portion of data.

**/

#[derive(Quantifiable)]
#[derive(Debug)]
pub struct MiniApp {}

impl MiniApp {

    pub fn new(traffic: String, arg:TrafficBuilderArgument) -> Box<dyn Traffic> {

        let traffic_cv = match traffic.as_str() {

            "Wavefront" => {
                let mut task_space = None;
                let mut message_size = None;

                match_object_panic!(arg.cv, "Wavefront", value,
                    "task_space" => task_space = Some(value.as_array().expect("Bad task_space value").iter().map(|v| v.as_f64().expect("Bad task_space value") as usize).collect()),
                    "message_size" => message_size = Some(value.as_f64().expect("Bad data_size value") as usize),
                );

                let task_space = task_space.expect("task_space is required");
                let message_size = message_size.expect("message_size is required");

                get_wavefront(task_space, message_size)
            },

			"All2AllLinear" => {
				let mut task_space = None;
				let mut message_size = None;

				match_object_panic!(arg.cv, "All2AllLinear", value,
					"task_space" => task_space = Some(value.as_array().expect("Bad task_space value").iter().map(|v| v.as_f64().expect("Bad task_space value") as usize).collect()),
					"message_size" => message_size = Some(value.as_f64().expect("Bad data_size value") as usize),
				);

				let task_space = task_space.expect("task_space is required");
				let message_size = message_size.expect("message_size is required");

				get_all2all_linear(task_space, message_size)
			}

            _ => panic!("Unknown traffic type: {}", traffic),
        };
        new_traffic(TrafficBuilderArgument{cv: &traffic_cv, ..arg})
    }

}

fn get_wavefront(task_space: Vec<usize>, message_size:usize) -> ConfigurationValue{
	let mut neighbours_vector = vec![];
	for i in 0..task_space.len(){
		let mut neighbours = vec![0; task_space.len()];
		neighbours[i] = 1;
		neighbours_vector.push(neighbours);
	}
	let inmediate_neighbours_builder = ImmediateNeighboursCVBuilder {
		sides: task_space.clone(),
		vector_neighbours: neighbours_vector,
		modular: false,
	};

	let inmediate_neighbours = immediate_neighbours_cv_builder(inmediate_neighbours_builder);

	let total_tasks = task_space.iter().product();
	let message_to_vector_builder = SendMessageToVectorCVBuilder{
		tasks: total_tasks,
		one_to_many_pattern: inmediate_neighbours,
		message_size,
		rounds: 1,
	};
	let message_to_vector = build_send_message_to_vector_cv(message_to_vector_builder);
	// let start = ConfigurationValue::Object("Hotspots".to_string(), vec![("destinations".to_string(), ConfigurationValue::Array(vec![ConfigurationValue::Number(0.0)]))]);

	let identity_pattern_vector = vec![ConfigurationValue::Object("Identity".to_string(), vec![]); task_space.len()];
	let initial_credits = ConfigurationValue::Object("Sum".to_string(), vec![
		("patterns".to_string(), ConfigurationValue::Array(
			(0..task_space.len()).into_iter().enumerate().map(|(i, _z)| {
				let mut patterns_cartesian_transform = identity_pattern_vector.clone();
				patterns_cartesian_transform[i] = get_hotspot_destination(vec![0]); //ConfigurationValue::Object("Hotspots".to_string(), vec![("destinations".to_string(),ConfigurationValue::Array())]);
				let pattern_cad_sel = get_cartesian_transform(task_space.clone(), None, Some(patterns_cartesian_transform));
				get_candidates_selection(pattern_cad_sel, total_tasks)
			}).collect())
		),
		("middle_sizes".to_string(), ConfigurationValue::Array(vec![ConfigurationValue::Number(2f64); task_space.len()])),
	]);
	let traffic_manager_builder = BuildTrafficManagerCVArgs{
		tasks: total_tasks,
		credits_to_activate: task_space.len(),
		messages_per_transition: task_space.len(),
		credits_per_received_message: 1,
		traffic: message_to_vector,
		initial_credits,
	};

	let traffic_manager = get_traffic_manager(traffic_manager_builder);
	traffic_manager
}


fn get_all2all_linear(task_space: Vec<usize>, message_size: usize) -> ConfigurationValue {
	let mut traffics_for_sequence = vec![];
	let total_tasks:usize = task_space.iter().product();

	for k in 0..task_space.len() {
		let mut all2all_dim = vec![];
		let mut specific_all2alls_side = task_space.clone();
		specific_all2alls_side.remove(k);
		let specific_all2alls = specific_all2alls_side.iter().product();
		let specific_all2alls_cartesian_data = CartesianData::new(&specific_all2alls_side);
		for i in 0..specific_all2alls {
			let all2all = super::collectives::get_all2all(task_space[k], message_size * task_space[k], 1);
			let cartesian_data_graphs = specific_all2alls_cartesian_data.unpack(i);
			let mut shift_vector = cartesian_data_graphs.clone();
			shift_vector.insert(k, 0);
			let mut matrix = vec![ vec![0i32; 1]; task_space.len()];
			matrix[k][0] = 1;
			let linear_transform_args = BuildLinearTransformCV {
				source_size: vec![task_space[k]],
				target_size: task_space.clone(),
				matrix,
			};
			let linear_transform = get_linear_transform(linear_transform_args);
			let cartesian_transform_args = BuildCartesianTransformCV{
				sides: task_space.clone(),
				shift: Some(shift_vector),
				..Default::default()
			};
			let cartesian_transform = get_cartesian_transform_from_builder(cartesian_transform_args);

			let composition_pattern_args = BuildCompositionCV{
				patterns: vec![linear_transform, cartesian_transform],
				..Default::default()
			};

			let map = get_composition_pattern_cv(composition_pattern_args);

			let traffic_map_args = BuildTrafficMapCVArgs {
				tasks: total_tasks,
				application: all2all,
				map
			};
			let traffic_map = build_traffic_map_cv(traffic_map_args);
			all2all_dim.push(traffic_map);
		}

		let traffic_sum_args = BuildTrafficSumCVArgs {
			tasks: task_space.iter().product(),
			list: all2all_dim,
			..Default::default()
		};
		let t_sum = build_traffic_sum_cv(traffic_sum_args);
		traffics_for_sequence.push(t_sum);
	}

	ConfigurationValue::Object("Sequence".to_string(), vec![
		("traffics".to_string(), ConfigurationValue::Array(traffics_for_sequence)),
	])
}



#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_wavefront() {
		let task_space = vec![10, 10, 10];
		let message_size = 16;
		let traffic = get_wavefront(task_space, message_size);
		println!("{}", traffic.format_terminal());
	}

	#[test]
	fn test_all2all_linear() {
		let task_space = vec![10, 10];
		let message_size = 16;
		let traffic = get_all2all_linear(task_space, message_size);
		println!("{}", traffic.format_terminal());
	}
	use rand::prelude::StdRng;
	use rand::SeedableRng;
	use crate::config_parser::ConfigurationValue;
	use crate::general_pattern::pattern::extra::get_candidates_selection;
	use crate::Plugs;
	use crate::traffic::new_traffic;

	#[test]
	fn test_traffic_manager() {
		let switches = 4.0;
		let mut rng = StdRng::seed_from_u64(0);
		let one_to_many_pattern = ConfigurationValue::Object("AllNeighbours".to_string(), vec![]);
		let cv_builder = super::SendMessageToVectorCVBuilder {
			tasks: 4,
			one_to_many_pattern,
			message_size: 16,
			rounds: 2,
		};
		let cv = super::build_send_message_to_vector_cv(cv_builder);

		let initial_credits =  get_candidates_selection(ConfigurationValue::Object("Identity".to_string(), vec![]), switches as usize);
		let traffic_manager_builder = super::BuildTrafficManagerCVArgs{
			tasks: 4,
			credits_to_activate: 1,
			messages_per_transition: 1,
			credits_per_received_message: 1,
			traffic: cv,
			initial_credits,
		};
		let traffic_manager = super::get_traffic_manager(traffic_manager_builder);
		println!("{}",traffic_manager.format_terminal() );


		let traffic_builder = super::TrafficBuilderArgument{
			cv: &traffic_manager,
			rng: &mut rng,
			plugs: &Plugs::default(),
			topology: None,
		};

		//Starts the traffic
		let mut t = new_traffic(traffic_builder);
		assert_eq!(t.number_tasks(), switches as usize);
		for _ in 0..(switches as usize -1) // extract all messages
		{
			let mut messages = vec![];

			for i in 0..switches as usize {
				assert_eq!(t.should_generate(i, 0, &mut rng), true); //inserting all2all
			}

			for i in 0..switches as usize {
				let message = t.generate_message(i, 0, None, &mut rng).unwrap();
				messages.push(message);
			}

			//now check that tasks are done and their state is FinishedGenerating. also traffic is not finished.
			for i in 0..(switches as usize) {
				assert_eq!(t.should_generate(i, 0, &mut rng), false);
			}

			for i in 0..messages.len() {
				assert_eq!(t.consume(messages[i].destination, &*messages[i], 0, None, &mut rng), true);
			}
		}

		assert_eq!(t.is_finished(Some(&mut rng)), false);

		for _ in 0..(switches as usize -1) // extract all messages
		{
			let mut messages = vec![];

			for i in 0..switches as usize {
				assert_eq!(t.should_generate(i, 0, &mut rng), true); //inserting all2all
			}

			for i in 0..switches as usize {
				let message = t.generate_message(i, 0, None, &mut rng).unwrap();
				messages.push(message);
			}

			//now check that tasks are done and their state is FinishedGenerating. also traffic is not finished.
			for i in 0..(switches as usize) {
				assert_eq!(t.should_generate(i, 0, &mut rng), false);
			}

			for i in 0..messages.len() {
				assert_eq!(t.consume(messages[i].destination, &*messages[i], 0, None, &mut rng), true);
			}
		}

		assert_eq!(t.is_finished(Some(&mut rng)), true);
	}

	#[test]
	fn test_message_size_modifier() {
		let switches = 4.0;
		let mut rng = StdRng::seed_from_u64(0);
		let one_to_many_pattern = ConfigurationValue::Object("AllNeighbours".to_string(), vec![]);
		let cv_builder = super::SendMessageToVectorCVBuilder {
			tasks: 4,
			one_to_many_pattern,
			message_size: 16,
			rounds: 2,
		};
		let cv = super::build_send_message_to_vector_cv(cv_builder);

		let initial_credits = get_candidates_selection(ConfigurationValue::Object("Identity".to_string(), vec![]), switches as usize);
		let traffic_manager_builder = super::BuildTrafficManagerCVArgs {
			tasks: 4,
			credits_to_activate: 1,
			messages_per_transition: 1,
			credits_per_received_message: 1,
			traffic: cv,
			initial_credits,
		};
		let traffic_manager = super::get_traffic_manager(traffic_manager_builder);

		let message_sizes = vec![16, 32, 64, 128, 256, 512];
		let message_size_modifier = super::get_message_size_modifier(super::BuildMessageSizeModifierCVArgs {
			tasks: 4,
			traffic: traffic_manager,
			message_sizes: message_sizes.clone(),
		});
		println!("{}", message_size_modifier.format_terminal());

		let traffic_builder = super::TrafficBuilderArgument {
			cv: &message_size_modifier,
			rng: &mut rng,
			plugs: &Plugs::default(),
			topology: None,
		};

		//Starts the traffic
		let mut t = new_traffic(traffic_builder);
		assert_eq!(t.number_tasks(), switches as usize);
		for iteration in 0..(switches as usize -1) // extract all messages
		{
			let mut messages = vec![];

			for i in 0..switches as usize {
				assert_eq!(t.should_generate(i, 0, &mut rng), true); //inserting all2all
			}

			for i in 0..switches as usize {
				let message = t.generate_message(i, 0, None, &mut rng).unwrap();
				assert_eq!(message.size, message_sizes[iteration]);
				messages.push(message);
			}

			//now check that tasks are done and their state is FinishedGenerating. also traffic is not finished.
			for i in 0..(switches as usize) {
				assert_eq!(t.should_generate(i, 0, &mut rng), false);
			}

			for i in 0..messages.len() {
				assert_eq!(t.consume(messages[i].destination, &*messages[i], 0, None, &mut rng), true);
			}
		}

		assert_eq!(t.is_finished(Some(&mut rng)), false);

		for iteration in 0..(switches as usize -1) // extract all messages
		{
			let mut messages = vec![];

			for i in 0..switches as usize {
				assert_eq!(t.should_generate(i, 0, &mut rng), true); //inserting all2all
			}

			for i in 0..switches as usize {
				let message = t.generate_message(i, 0, None, &mut rng).unwrap();
				assert_eq!(message.size, message_sizes[iteration + (switches as usize -1)]);
				messages.push(message);
			}

			//now check that tasks are done and their state is FinishedGenerating. also traffic is not finished.
			for i in 0..(switches as usize) {
				assert_eq!(t.should_generate(i, 0, &mut rng), false);
			}

			for i in 0..messages.len() {
				assert_eq!(t.consume(messages[i].destination, &*messages[i], 0, None, &mut rng), true);
			}
		}

		assert_eq!(t.is_finished(Some(&mut rng)), true);
	}
}
