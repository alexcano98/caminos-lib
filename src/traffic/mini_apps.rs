use std::default::Default;
use std::cell::RefCell;
use std::cmp::max;
use crate::pattern::extra::{get_hotspot_destination, get_switch_pattern};
use std::collections::BTreeSet;
use std::convert::TryInto;
use std::rc::Rc;
use quantifiable_derive::Quantifiable;

use rand::prelude::StdRng;
use crate::{match_object_panic, Message, Time};

use crate::Pattern;
use crate::AsMessage;
use crate::config_parser::ConfigurationValue;
use crate::pattern::{new_pattern, PatternBuilderArgument};
use crate::topology::Topology;
use crate::traffic::{new_traffic, TaskTrafficState, Traffic, TrafficBuilderArgument, TrafficError};
use crate::traffic::basic::{build_message_cv, BuildMessageCVArgs};
use crate::traffic::{build_traffic_sum_cv, build_traffic_map_cv, BuildTrafficMapCVArgs, BuildTrafficSumCVArgs};
use crate::traffic::collectives::{get_all2all};
use crate::traffic::TaskTrafficState::{Finished, FinishedGenerating, Generating, UnspecifiedWait};
use crate::pattern::extra::{get_candidates_selection,get_cartesian_transform};
use crate::pattern::{get_cartesian_transform_from_builder, get_linear_transform, BuildCartesianTransformCV, BuildLinearTransformCV, get_composition_pattern_cv, BuildCompositionCV};
use crate::topology::cartesian::CartesianData;

/**
Traffic which allows tasks to generate messages when they have enough credits.
After generating the messages, the credits are consumed.
A task gains credits when it consumes messages, and an initial number of credits per task can be set.
```ignore
TrafficCredit{
	pattern: RandomPermutation, //specify the pattern of the communication
	tasks: 1000, //specify the number of tasks
	credits_to_activate: 10, //specify the number of credits needed to generate messages
	messages_per_transition: 1, //specify the number of messages each task can sent when consuming credits
	credits_per_received_message: 1, //specify the number of credits to gain when a message is received
	message_size: 16, //specify the size of each sent message
	message_size_pattern: Hotspots{destinations:[128]} //Variable message size to add depending on the task
	initial_credits: Hotspots{destinations: [1]}, //specify the initial amount of credits per task
}
```
 **/
#[derive(Quantifiable)]
#[derive(Debug)]
pub struct TrafficCredit
{
	///Number of tasks applying this traffic.
	tasks: usize,
	///The pattern of the communication.
	pattern: Box<dyn Pattern>,
	///Credits needed to activate the transition
	credits_to_activate:usize,
	///Credit count per origin
	credits: Vec<usize>,
	///The credits to sum when a message is received
	credits_per_received_message:usize,
	///The size of each sent message.
	message_size: usize,
	///Pattern message size, variable
	message_size_pattern: Option<Box<dyn Pattern>>,
	///Messages per transition
	messages_per_transition:usize,
	///The number of messages each task has pending to sent.
	pending_messages: Vec<usize>,
	///Set of generated messages. (For debug purposes.)
	generated_messages: BTreeSet<u128>,
	next_id: u128,
}

impl Traffic for TrafficCredit
{
	fn generate_message(&mut self, origin:usize, cycle:Time, topology:&dyn Topology, rng: &mut StdRng) -> Result<Rc<Message>,TrafficError>
	{
		if origin>=self.tasks
		{
			panic!("origin {} does not belong to the traffic",origin);
			// return Err(TrafficError::OriginOutsideTraffic);
		}
		if self.pending_messages[origin] == 0
		{
			panic!("origin {} has no pending messages",origin);
		}
		self.pending_messages[origin]-=1;
		let destination=self.pattern.get_destination(origin, topology, rng);
		if origin==destination
		{
			return Err(TrafficError::SelfMessage);
		}
		let id = self.next_id;
		let message_size = self.message_size + if let Some(patron) = self.message_size_pattern.as_ref(){
			patron.get_destination(origin,topology,rng)
		}else{
			0
		};
		let message=Rc::new(Message{
			origin,
			destination,
			size: message_size,
			creation_cycle: cycle,
			payload: id.to_le_bytes().into(),
			id_traffic: None,
		});
		self.generated_messages.insert(id);

		self.next_id += 1;
		Ok(message)
	}
	fn probability_per_cycle(&self, task:usize) -> f32
	{
		if self.pending_messages[task]>0
		{
			1.0
		}
		else
		{
			0.0
		}
	}

	fn should_generate( &mut self, task:usize, _cycle:Time, _rng: &mut StdRng) -> bool
	{
		while self.credits[task] >= self.credits_to_activate
		{
			self.pending_messages[task] += self.messages_per_transition;
			self.credits[task] -= self.credits_to_activate;
		}
		self.pending_messages[task] > 0
	}

	fn consume(&mut self, task:usize, message: &dyn AsMessage, _cycle:Time, _topology:&dyn Topology, _rng: &mut StdRng) -> bool
	{
		self.credits[task] += self.credits_per_received_message;
		let id = u128::from_le_bytes(message.payload()[0..16].try_into().expect("bad payload"));
		 if self.generated_messages.remove(&id)
		 {
			 true
		 }
		 else
		 {
			 panic!("Message {} was not generated by TrafficCredit",id);
		 }
	}
	fn is_finished(&self) -> bool
	{
		if !self.generated_messages.is_empty() //messages traveling through the network
		{
			return false;
		}

		if self.pending_messages.iter().sum::<usize>() > 0 //messages waiting to be sent
		{
			return false;
		}

		//if there is a task with enough credits to activate, then it is not finished
		for &c in self.credits.iter()
		{
			if c >= self.credits_to_activate
			{
				return false;
			}
		}
		true
	}
	fn task_state(&self, task:usize, _cycle:Time) -> Option<TaskTrafficState>
	{
		if self.pending_messages[task]>0 {
			Some(Generating)
		} else {
			//We do not know whether someone is sending us data.
			//if self.is_finished() { TaskTrafficState::Finished } else { TaskTrafficState::UnspecifiedWait }
			// Sometimes it could be Finished, but it is not worth computing...
			Some(UnspecifiedWait)
		}
	}

	fn number_tasks(&self) -> usize {
		self.tasks
	}
}

impl TrafficCredit
{
	pub fn new(arg:TrafficBuilderArgument) -> TrafficCredit
	{
		let mut tasks=None;
		let mut pattern =None;
		let mut credits_to_activate=None;
		let mut credits_per_received_message=None;
		let mut message_size=None;
		let mut messages_per_transition=None;
		let mut initial_credits=None;
		let mut message_size_pattern = None;

		match_object_panic!(arg.cv,"TrafficCredit",value,
			"pattern" => pattern=Some(new_pattern(PatternBuilderArgument{cv:value,plugs:arg.plugs})),
			"tasks" | "servers" => tasks=Some(value.as_usize().expect("bad value for tasks")),
			"credits_to_activate" => credits_to_activate=Some(value.as_usize().expect("bad value for credits_to_activate")),
			"credits_per_received_message" => credits_per_received_message=Some(value.as_usize().expect("bad value for credits_per_received_message")),
			"message_size" => message_size=Some(value.as_usize().expect("bad value for message_size") ),
			"messages_per_transition" => messages_per_transition=Some(value.as_usize().expect("bad value for messages_per_transition")),
			"initial_credits" => initial_credits=Some(new_pattern(PatternBuilderArgument{cv:value,plugs:arg.plugs})),
			"message_size_pattern" => message_size_pattern=Some(new_pattern(PatternBuilderArgument{cv:value,plugs:arg.plugs})),
		);

		let tasks=tasks.expect("There were no tasks");
		let mut pattern = pattern.expect("There were no pattern");
		let credits_to_activate=credits_to_activate.expect("There were no credits_to_activate");
		let credits_per_received_message=credits_per_received_message.expect("There were no credits_per_received_message");
		let message_size=message_size.expect("There were no message_size");
		let messages_per_transition=messages_per_transition.expect("There were no messages_per_transition");
		let mut initial_credits=initial_credits.expect("There were no initial_credits");

		pattern.initialize(tasks, tasks, arg.topology, arg.rng);
		initial_credits.initialize(tasks, tasks, arg.topology, arg.rng);
		let pending_messages = vec![0;tasks];

		let credits = (0..tasks).map(|i| initial_credits.get_destination(i, arg.topology, arg.rng)).collect::<Vec<usize>>();

		if let Some(patron) = message_size_pattern.as_mut(){
			patron.initialize(tasks, tasks, arg.topology, arg.rng);
		}
		TrafficCredit{
			tasks,
			pattern,
			credits_to_activate,
			credits,
			credits_per_received_message,
			message_size,
			message_size_pattern,
			messages_per_transition,
			pending_messages,
			generated_messages: BTreeSet::new(),
			next_id: 0,
		}
	}
}

pub struct BuildTrafficCreditCVArgs{
	pub tasks: usize,
	pub credits_to_activate:usize,
	pub messages_per_transition: usize,
	pub credits_per_received_message: usize,
	pub message_size: usize,
	pub pattern: ConfigurationValue,
	pub initial_credits: ConfigurationValue,
	pub message_size_pattern: Option<ConfigurationValue>
}


pub fn get_traffic_credit(args: BuildTrafficCreditCVArgs) -> ConfigurationValue
{
	let mut arg_vec = vec![
		("tasks".to_string(), ConfigurationValue::Number(args.tasks as f64)),
		("credits_to_activate".to_string(), ConfigurationValue::Number(args.credits_to_activate as f64)),
		("messages_per_transition".to_string(), ConfigurationValue::Number(args.messages_per_transition as f64)),
		("credits_per_received_message".to_string(), ConfigurationValue::Number(args.credits_per_received_message as f64)),
		("message_size".to_string(), ConfigurationValue::Number(args.message_size as f64)),
		("pattern".to_string(), args.pattern),
		("initial_credits".to_string(), args.initial_credits),
	];

	if let Some(message_size_pattern) = args.message_size_pattern {
		arg_vec.push(("message_size_pattern".to_string(), message_size_pattern));
	}

	ConfigurationValue::Object("TrafficCredit".to_string(), arg_vec)
}

/**
Mini-Kernels which imitate the behaviour of real applications.

## Wavefront
The wavefront traffic is applied over an n-dimensional space.
Starts in the corner of the space (0,0,...,0) and ends in the opposite corner (n-1, n-1, ..., n-1).

```ignore
	Wavefront{
		task_space: [10,10,10],
		data_size: 16,
	}
```

## LinearAll2All
The LinearAll2All traffic generates all2all in each row, column, etc., depending on the task space.
It is like an FFT.

```ignore
	LinearAll2All{
		task_space: [10,10],
		message_size: 16,
	}
```
This could simulate a FFT3D, where each task contains a portion of data.
**/

#[derive(Quantifiable)]
#[derive(Debug)]
pub struct MiniApp {}

impl MiniApp {

    pub fn new(traffic: String, arg:TrafficBuilderArgument) -> Box<dyn Traffic> {

        let traffic_cv = match traffic.as_str() {

            "Wavefront" => {
                let mut task_space = None;
                let mut data_size = None;

                match_object_panic!(arg.cv, "Wavefront", value,
                    "task_space" => task_space = Some(value.as_array().expect("Bad task_space value").iter().map(|v| v.as_f64().expect("Bad task_space value") as usize).collect()),
                    "data_size" => data_size = Some(value.as_f64().expect("Bad data_size value") as usize),
                );

                let task_space = task_space.expect("task_space is required");
                let data_size = data_size.expect("data_size is required");

                get_wavefront(task_space, data_size)
            },
			"LinearAll2All" => { // All2All in the task space. Its like an FFT
				let mut task_space = None;
				let mut message_size = None;
				match_object_panic!(arg.cv, "LinearAll2All", value,
					"task_space" => task_space = Some(value.as_array().expect("Bad task_space value").iter().map(|v| v.as_f64().expect("Bad task_space value") as usize).collect()),
					"message_size" => message_size = Some(value.as_f64().expect("Bad message_size value") as usize),
				);

				let task_space = task_space.expect("task_space is required");
				let message_size = message_size.expect("message_size is required");

				get_all2all_linear(task_space, message_size)
			}
            _ => panic!("Unknown traffic type: {}", traffic),
        };
        new_traffic(TrafficBuilderArgument{cv: &traffic_cv, ..arg})
    }

}

fn get_all2all_linear(task_space: Vec<usize>, message_size: usize) -> ConfigurationValue {
	let mut traffics_for_sequence = vec![];
	let total_tasks:usize = task_space.iter().product();
	// let cartesian_data = CartesianData::new(&task_space);
	for k in 0..task_space.len() {
		let mut all2all_dim = vec![];
		let mut specific_all2alls_side = task_space.clone();
		specific_all2alls_side.remove(k);
		let specific_all2alls = specific_all2alls_side.iter().product();
		let specific_all2alls_cartesian_data = CartesianData::new(&specific_all2alls_side);
		for i in 0..specific_all2alls {
			let all2all = get_all2all(task_space[k], message_size * task_space[k], 1);
			let cartesian_data_graphs = specific_all2alls_cartesian_data.unpack(i);
			let mut shift_vector = cartesian_data_graphs.clone();
			shift_vector.insert(k, 0);
			let mut matrix = vec![ vec![0i32; 1]; task_space.len()];
			matrix[k][0] = 1;
			let linear_transform_args = BuildLinearTransformCV {
				source_size: vec![task_space[k]],
				target_size: task_space.clone(),
				matrix,
			};
			let linear_transform = get_linear_transform(linear_transform_args);
			let cartesian_transform_args = BuildCartesianTransformCV{
				sides: task_space.clone(),
				shift: Some(shift_vector),
				..Default::default()
			};
			let cartesian_transform = get_cartesian_transform_from_builder(cartesian_transform_args);

			let composition_pattern_args = BuildCompositionCV{
				patterns: vec![linear_transform, cartesian_transform],
				..Default::default()
			};

			let map = get_composition_pattern_cv(composition_pattern_args);

			let traffic_map_args = BuildTrafficMapCVArgs {
				tasks: total_tasks,
				application: all2all,
				map
			};
			let traffic_map = build_traffic_map_cv(traffic_map_args);
			all2all_dim.push(traffic_map);
		}

		let traffic_sum_args = BuildTrafficSumCVArgs {
			tasks: task_space.iter().product(),
			list: all2all_dim,
			..Default::default()
		};
		let t_sum = build_traffic_sum_cv(traffic_sum_args);
		traffics_for_sequence.push(t_sum);
	}
	ConfigurationValue::Object("Sequence".to_string(), vec![
		("traffics".to_string(), ConfigurationValue::Array(traffics_for_sequence)),
	])
}

fn get_wavefront(task_space: Vec<usize>, data_size:usize) -> ConfigurationValue{
	let tasks = task_space.iter().product();
	let _task_space_cv: Vec<_> = task_space.iter().map(|&v| ConfigurationValue::Number(v as f64)).collect();

	let mut num_messages = 0;
	for i in 0..task_space.len(){
		let mut mul = 1;
		for j in 0..task_space.len(){
			if i != j{
				mul *= task_space[j];
			}else{
				mul *= max(task_space[j] - 1, 1);
			}
		}
		num_messages += mul;
	}

	let identity_pattern_vector = vec![ConfigurationValue::Object("Identity".to_string(), vec![]); task_space.len()];

	let initial_credits = ConfigurationValue::Object("Sum".to_string(), vec![
		("patterns".to_string(), ConfigurationValue::Array(
			(0..task_space.len()).into_iter().enumerate().map(|(i, _z)| {
					let mut patterns_cartesian_transform = identity_pattern_vector.clone();
					patterns_cartesian_transform[i] = get_hotspot_destination(vec![0]); //ConfigurationValue::Object("Hotspots".to_string(), vec![("destinations".to_string(),ConfigurationValue::Array())]);
					let pattern_cad_sel = get_cartesian_transform(task_space.clone(), None, Some(patterns_cartesian_transform));
				  get_candidates_selection(pattern_cad_sel, tasks)
			}).collect())
		),
		("middle_sizes".to_string(), ConfigurationValue::Array(vec![ConfigurationValue::Number(2f64); task_space.len()])),
	]);

	let traffic_credit_pattern = (0..task_space.len()).into_iter().map(|i|
	 {
		 let mut patterns = identity_pattern_vector.clone();
		 patterns[i]= get_hotspot_destination(vec![task_space[i] -1]);
		 let cartesian_transform = get_cartesian_transform(task_space.clone(), None, Some(patterns));
		 let switch_indexing = get_candidates_selection(cartesian_transform, tasks);
		 let mut shift = vec![0; task_space.len()];
		 shift[i] = 1;
		 let switch_patterns = vec![
			 get_cartesian_transform(task_space.clone(), Some(shift), None),
			 ConfigurationValue::Object("Identity".to_string(), vec![]), //Its in a edge of the n-dimensional space
		 ];
		 get_switch_pattern(switch_indexing, switch_patterns)
	 }
	).collect();
	let traffic_credit_pattern = ConfigurationValue::Object( "RoundRobin".to_string(), vec![
		("patterns".to_string(), ConfigurationValue::Array(traffic_credit_pattern)),
	]);

	let traffic_credit_params = BuildTrafficCreditCVArgs {
		tasks,
		credits_to_activate: task_space.len(),
		messages_per_transition: task_space.len(),
		message_size: data_size,
		credits_per_received_message: 1,
		pattern: traffic_credit_pattern,
		initial_credits,
		message_size_pattern: None
	};

	let traffic_credit = get_traffic_credit(traffic_credit_params);

	let traffic_message_cv_builder = BuildMessageCVArgs{
		traffic: traffic_credit.clone(),
		tasks,
		num_messages,
		messages_per_task: None,
		expected_messages_to_consume_per_task: Some(task_space.len()),
	};

	build_message_cv(traffic_message_cv_builder)
}

/**
Stencil traffic pattern. Get destinations from a pattern and send messages to each destination available.
The pattern should not repeat destinations from each source.

```ignore
Stencil{
	tasks: 9,
	pattern: KingNeighbours{ //Iter the neighbours inside a chessboard distance. No wrap-around
		sides: [3,3],
		distance: 1,
	},
	message_size: 16,
	messages_per_destination: 1,
}
```
**/
#[derive(Quantifiable)]
#[derive(Debug)]
pub struct Stencil
{
	///Number of tasks applying this traffic.
	tasks: usize,
	///The size of each sent message.
	message_size: usize,
	///The number of messages each task can sent to each destination.
	messages_per_destination: usize,
	///The destinations of each task.
	destinations: Vec<Vec<usize>>,
	///The index of the next destination to send a message.
	index_to_send: Vec<usize>,
	///The number of messages each task has sent to each destination.
	messages_sent: Vec<Vec<usize>>,
	///The number of messages to recieve
	messages_to_recieve: RefCell<Vec<usize>>,
	///id of the next message to generate
	next_id: u128,
	///Set of generated messages.
	generated_messages: BTreeSet<u128>,
}

impl Traffic for Stencil
{
	fn generate_message(&mut self, origin: usize, cycle: Time, _topology: &dyn Topology, _rng: &mut StdRng) -> Result<Rc<Message>, TrafficError> {
		let id = self.next_id;
		let index_to_send = self.index_to_send[origin];

		let destination = self.destinations[origin][index_to_send];
		self.messages_sent[origin][index_to_send] += 1;
		self.generated_messages.insert(id);

		self.index_to_send[origin] = (index_to_send+1) % self.destinations[origin].len();
		self.next_id += 1;

		Ok(Rc::new(Message {
			origin,
			destination,
			size: self.message_size,
			creation_cycle: cycle,
			payload: id.to_le_bytes().into(),
			id_traffic: None,
		}))
	}

	fn probability_per_cycle(&self, task: usize) -> f32 {
		if self.messages_sent[task][self.index_to_send[task]] < self.messages_per_destination
		{
			1.0
		}
		else
		{
			0.0
		}
	}

	fn consume(&mut self, task: usize, message: &dyn AsMessage, _cycle: Time, _topology: &dyn Topology, _rng: &mut StdRng) -> bool {
		let mut consumed_messages = self.messages_to_recieve.borrow_mut();
		if consumed_messages[task] == 0
		{
			panic!("Task {} has no messages to consume", task);
		}
		consumed_messages[task] -= 1;
		let id = u128::from_le_bytes(message.payload()[0..16].try_into().expect("bad payload"));
		self.generated_messages.remove(&id)
	}

	fn is_finished(&self) -> bool {
		self.generated_messages.is_empty() && self.messages_sent.iter().enumerate().all(|(i,v)| v[self.index_to_send[i]] == self.messages_per_destination)
	}

	fn should_generate(&mut self, task: usize, _cycle: Time, _rng: &mut StdRng) -> bool {
		self.messages_sent[task][self.index_to_send[task]] < self.messages_per_destination
	}

	fn task_state(&self, task: usize, _cycle: Time) -> Option<TaskTrafficState> {
		if self.messages_sent[task][self.index_to_send[task]] < self.messages_per_destination {
			Some(Generating)
		} else {
			if self.messages_to_recieve.borrow()[task] > 0 {
				Some(FinishedGenerating)
			} else {
				Some(Finished)
			}
		}
	}

	fn number_tasks(&self) -> usize {
		self.tasks
	}
}

impl Stencil
{
	pub fn new(arg: TrafficBuilderArgument) -> Stencil
	{
		let mut tasks = None;
		let mut pattern_cv = None;
		let mut message_size = None;
		let mut messages_per_destination = None;

		match_object_panic!(arg.cv, "Stencil", value,
			"tasks" => tasks = Some(value.as_usize().expect("bad value for tasks")),
			"pattern" => pattern_cv = Some(value),
			"message_size" => message_size = Some(value.as_usize().expect("bad value for message_size")),
			"messages_per_destination" => messages_per_destination = Some(value.as_usize().expect("bad value for messages_per_destination")),
		);

		let tasks = tasks.expect("There were no tasks");
		let pattern_cv = pattern_cv.expect("There were no pattern");
		let messages_per_destination = messages_per_destination.expect("There were no messages_per_destination");
		let message_size = message_size.expect("There were no message_size");
		// let pattern = new_pattern(PatternBuilderArgument{cv:pattern_cv, plugs:arg.plugs});

		let mut pattern_count = new_pattern(PatternBuilderArgument{cv:pattern_cv, plugs:arg.plugs});
		pattern_count.initialize(tasks, tasks, arg.topology, arg.rng);
		let mut messages_per_task = vec![vec![]; tasks];
		let mut destinations_per_task = vec![vec![]; tasks];
		let mut messages_to_recieve = vec![0; tasks];

		'outer: for i in 0..tasks{
			let mut destinations = vec![];
			for _ in 0..tasks{
				let dest = pattern_count.get_destination(i, arg.topology, arg.rng);
				if !destinations.contains(&dest){
					destinations.push(dest);
				} else {
					messages_per_task[i] = vec![0; destinations.len()];
					messages_to_recieve[i] = destinations.len() * messages_per_destination;
					destinations_per_task[i] = destinations;
					continue 'outer;
				}
			}
			messages_per_task.push(vec![0; destinations.len()]);
			messages_to_recieve.push(destinations.len() * messages_per_destination);
			destinations_per_task.push(destinations);
		}

		Stencil{
			tasks,
			message_size,
			messages_per_destination,
			destinations: destinations_per_task,
			index_to_send: vec![0; tasks],
			messages_sent: messages_per_task,
			messages_to_recieve: RefCell::new(messages_to_recieve),
			next_id: 0,
			generated_messages: BTreeSet::new(),
		}
	}
}

#[cfg(test)]
mod tests {
	use crate::traffic::mini_apps::{get_all2all_linear, get_wavefront};

	#[test]
	fn test_wavefront() {
		let wavefront_cv = get_wavefront(vec![3,3], 16);
		println!("{}", wavefront_cv.format_terminal());
	}

	#[test]
	fn test_all2all_linear() {
		let all2all_linear_cv = get_all2all_linear(vec![3,3], 16);
		println!("{}", all2all_linear_cv.format_terminal());
	}
}